好了，接下来我们来看看ARCII模型的代码，仍然我们定义一个模型类，它继承自父类baseModel，我们只需要在这个模型类里面实现build方法就完成了网络的搭建工作了。
首先定义两个输入，然后定义一个词向量层作为两个输入的共享embedding，然后使用1维卷积对这两个输入语句提取特征，卷积填充方式使用same，呢么输出的features map就和输入的语句一样长了（35），我们使用的卷积核数量为32个，那么最终我们得到两个 batch size * 35 * 32 的数组。
我们没有使用池化层，直接降这两个数组进行交互matching，使用点乘dot的方式。这其实就是计算了两个句子之间的所有字的相互之间的余弦相似度了，得到交互矩阵，接着再使用 num_blocks 个2维卷积提取特征，然后展平，接多层感知机做分类再输出。
这里再介绍一下MatchingLayer的实现。我们直接看这个call方法，如果使用dot的交互方式的话，就需要先将features map进行l2规范化，这里tf.einsum就是矩阵的计算，'abd,acd->abc' 的操作表示将一个 batchsize*35*32 的数组 和batchsize*35*32的数组进行矩阵相乘，首先将batchsize*35*32数组转化成batchsize*32*35的数组，然后与batchsize*35*35数组相乘 ，最终得到一个batchsize*b*c的数组。tf.expand_dims表示给多维数组添加一个维度，这里表示添加第4维，从而将batchsize*35*35三维数组转化成batchsize*35*35*1的四维数组了，这个第四为就相当于图片数据的通道，之所以这样做是因为后面需要接二维卷积操作。这里还有相乘、相加、相减和拼接的交互方式实现我就不一一细讲了